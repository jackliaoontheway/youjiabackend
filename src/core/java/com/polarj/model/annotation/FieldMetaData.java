package com.polarj.model.annotation;

import static java.lang.annotation.ElementType.FIELD;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.polarj.model.enumeration.SearchType;

// 此注解用于描述模型字段的元数据，为数据验证，呈现等做准备
@Retention(RetentionPolicy.RUNTIME)
@Target(FIELD)
public @interface FieldMetaData
{
    // 如果属性是一个注释为@Embeddable的类，需要把标志设置为true
    // FIXME：在前端需要做相应处理
    boolean embedded() default false;

    // 字段在表格中的位置
    int position();

    boolean autogenerated() default false;

    // 字段是否显示在表格中（可以用户自己设置）
    boolean hide() default false;

    // 字段是否显示在明细中（可以用户自己设置）
    boolean detailHide() default false;

    // 数据类型：都是 TypeScript 的数据类型(string, number, boolean, date, email,
    // object, array)，全部小写
    // 业务模型中的List<模型类>属性，标识为array
    // 业务模型中属性是模型类的，标识为object，
    // labelField描述属性模型类的哪个属性值代表这个属性类的值
    String dataType() default "string";

    // 数据校验的正则表达式（js和Java在这个方面的区别是什么？）
    String pattern() default "";

    String label();

    String tip() default "";

    // 数据显示的格式
    String formatter() default "";

    // 是否必填项
    boolean required() default false;

    // 是否管理员才能处理的属性
    boolean adminReserved() default false;

    String minVal() default "";

    String maxVal() default "";

    // 枚举类型的值超过3个少于10个的使用select元素
    // 3个及以下的使用radiobutton或者checkbox
    // 10个及以上的使用autocomplete的输入
    Class<?> enumClass() default Object.class;

    // 如果enumClass()的值是一般的类类型，使用这个属性值来表示被注解的属性的值的来源
    String enumValueField() default "";

    // 1. 如果enumClass()的值是一般的类类型，
    // 那么这个属性指出类中哪个属性用于页面的label
    // FIXME： 前端还没有实现：
    // 2. 针对一般的类属性（dataType的值是object或者array，enumClass的值为缺省值），
    // 则使用这个属性描述属性模型类的哪个属性值代表这个属性类的值
    String labelField() default "";

    int minLength() default 0;

    int maxLength() default 0;

    String defaultValue() default "";

    // 是否可以选多个值
    boolean multiChoice() default false;

    // 指定某个需要持久化的属性是单独管理的
    // 如果是对一的关系，那么这是一个单选，如果是对多的关系，就是一个多选
    // 从客户端更新模型时，该属性只有id传到后端，需要根据id读取所有的数据
    // FIXME： 前端还没有实现：
    // 客户端新增时，如果历史数据中没有需要的值，也需要新增类对象
    // （比如订单的买家，买家数据本身是单独管理的，但是在输入新订单数据时，
    // 不一定就能找到老客户，这个时候，需要保存客户端新输入的数据）
    boolean managementSeparately() default false;

    // 该字段是否可以用于排序
    boolean sortable() default false;

    // 允许什么样的查询，目前有值查询和范围查询两种， QUES：还可以增加多选，在SQL中相当于IN
    SearchType searchType() default SearchType.NONE;

    // 如果这个这个字段是一个经过计算后得到的数据， 这个属性描述计算类
    Class<?> classForCalField() default Object.class;

    // 如果这个这个字段是一个经过计算后得到的数据， 这个属性描述计算过程中需要的参数
    Class<?> paramClassForCalClass() default Object.class;

    // 如果业务类的属性是另外一个业务类（业务类属性），且该业务类属性是独立管理的，
    // 需要该元数据来说明除了id，还有哪个属性数据可以唯一标识该业务类属性
    // 增加该元数据是为了数据上传使用
    String uniqueField() default "";

    // 对于object和array的数据，上传或者下载的时候，是不是需要详细信息。
    // 一般对于独立管理和不重要的信息（比如：owner信息，这个时候只使用labelField指定的信息即可）
    // 就可以设置为不需要详细信息，这个属性不需要持久化。
    boolean hasDetail() default true;

    // 对于enumClass 通过owner来过滤 属于owner的数据
    boolean hasOwner() default false;
}
